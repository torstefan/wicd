From: Matthieu Baerts <matttbe@gmail.com>
Subject: Added the compatibility with python2.7
Origin: vendor, http://repos.archlinux.org/wsvn/packages/wicd/trunk/deepcopy%2Bpython27-fixes.patch
Origin: upstream, http://bazaar.launchpad.net/~wicd-devel/wicd/experimental/revision/564
Bug: https://bugs.launchpad.net/wicd/+bug/602825
Forwarded: yes

---
 wicd/configmanager.py |   39 +++++++++++++++++++++++----------------
 1 file changed, 23 insertions(+), 16 deletions(-)

--- wicd.orig/wicd/configmanager.py
+++ wicd/wicd/configmanager.py
@@ -24,7 +24,7 @@ reusable for other purposes as well.
 #   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-import os, copy
+import sys, os, copy
 
 from ConfigParser import RawConfigParser, ParsingError
 
@@ -35,7 +35,10 @@ from dbus import Int32
 class ConfigManager(RawConfigParser):
     """ A class that can be used to manage a given configuration file. """
     def __init__(self, path, debug=False, mark_whitespace="`'`"):
-        RawConfigParser.__init__(self)
+        if sys.version_info >= (2, 7, 0):
+            RawConfigParser.__init__(self, allow_no_value=True)
+        else:
+            RawConfigParser.__init__(self)
         self.config_file = path
         self.debug = debug
         self.mrk_ws = mark_whitespace
@@ -46,7 +49,6 @@ class ConfigManager(RawConfigParser):
             try:
                 self.read(path)
             except ParsingError, p:
-                import sys
                 print "Could not start wicd: %s" % p.message
                 sys.exit(1)
 
@@ -185,28 +187,33 @@ class ConfigManager(RawConfigParser):
 
 
     def _copy_section(self, name):
-        # Yes, deepcopy sucks, but it is robust to changes in both
-        # this class and RawConfigParser.
-        p = copy.deepcopy(self)
-        for sname in p.sections():
-            if sname != name:
-                p.remove_section(sname)
+        p = ConfigManager("", self.debug, self.mrk_ws)
+        p.add_section(name)
+        for (iname, value) in self.items(name):
+            p.set(name, iname, value)
+        # Store the filename this section was read from.
         p.config_file = p.get_option(name, '_filename_', p.config_file)
         p.remove_option(name, '_filename_')
         return p
 
     def write(self):
         """ Writes the loaded config file to disk. """
-        # Really don't like this deepcopy.
-        p = copy.deepcopy(self)
-        for sname in p.sections():
-            fname = p.get_option(sname, '_filename_')
+        in_this_file = []
+        for sname in self.sections():
+            fname = self.get_option(sname, '_filename_')
             if fname and fname != self.config_file:
                 section = self._copy_section(sname)
-                p.remove_section(sname)
                 section._write_one()
+            else:
+                # Save names of local sections
+                in_this_file.append(sname)
 
-        for sname in p.sections():
+        # Make an instance with only these sections
+        p = ConfigManager("", self.debug, self.mrk_ws)
+        p.config_gile = self.config_file
+        for sname in in_this_file:
+            p.add_section(sname)
+            for (iname, value) in self.items(name):
+                p.set(sname, iname, value)
             p.remove_option(sname, '_filename_')
         p._write_one()
-
